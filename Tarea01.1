comparator v/s comparable con objetos

En Java, tanto `Comparable` como `Comparator` se utilizan para definir el orden de los objetos, pero tienen diferencias clave en c√≥mo se implementan y cu√°ndo se deben usar.

---

### **1. `Comparable<T>` (Orden natural de los objetos)**
- Se implementa en la propia clase del objeto.
- Define un √∫nico criterio de ordenaci√≥n "natural".
- Se usa cuando la clase misma tiene un orden l√≥gico y debe ser comparable con otras instancias de la misma clase.
- Implementa el m√©todo `compareTo(T o)`, que devuelve:
  - Un n√∫mero negativo si el objeto actual es menor que el argumento.
  - Cero si son iguales.
  - Un n√∫mero positivo si es mayor.

#### **Ejemplo de `Comparable`**
```java
class Persona implements Comparable<Persona> {
    String nombre;
    int edad;

    public Persona(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    @Override
    public int compareTo(Persona otra) {
        return Integer.compare(this.edad, otra.edad); // Ordena por edad
    }

    @Override
    public String toString() {
        return nombre + " (" + edad + ")";
    }
}
```
**Uso en `Collections.sort()`**
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<Persona> personas = new ArrayList<>();
        personas.add(new Persona("Juan", 30));
        personas.add(new Persona("Ana", 25));
        personas.add(new Persona("Luis", 35));

        Collections.sort(personas); // Ordena por edad

        System.out.println(personas);
    }
}
```

---

### **2. `Comparator<T>` (Orden personalizado y flexible)**
- Se usa cuando se quiere ordenar objetos de una clase sin modificar la clase en s√≠.
- Permite m√∫ltiples criterios de comparaci√≥n.
- Se implementa en una clase externa o con expresiones lambda.
- Implementa el m√©todo `compare(T o1, T o2)`, que devuelve:
  - Un n√∫mero negativo si `o1` es menor que `o2`.
  - Cero si son iguales.
  - Un n√∫mero positivo si `o1` es mayor que `o2`.

#### **Ejemplo de `Comparator`**
```java
import java.util.*;

class ComparadorPorNombre implements Comparator<Persona> {
    @Override
    public int compare(Persona p1, Persona p2) {
        return p1.nombre.compareTo(p2.nombre); // Ordena por nombre alfab√©ticamente
    }
}
```

**Uso en `Collections.sort()`**
```java
public class Main {
    public static void main(String[] args) {
        List<Persona> personas = new ArrayList<>();
        personas.add(new Persona("Juan", 30));
        personas.add(new Persona("Ana", 25));
        personas.add(new Persona("Luis", 35));

        // Ordenar por nombre usando Comparator
        Collections.sort(personas, new ComparadorPorNombre());

        System.out.println(personas);
    }
}
```

**Uso con Expresi√≥n Lambda (`Comparator.comparing`)**
```java
Collections.sort(personas, Comparator.comparing(p -> p.nombre)); // Ordena por nombre
```

---

### **¬øCu√°ndo usar `Comparable` y cu√°ndo `Comparator`?**
| **Caracter√≠stica** | **Comparable** | **Comparator** |
|-------------------|--------------|--------------|
| ¬øD√≥nde se define? | En la misma clase del objeto. | En una clase separada o con expresiones lambda. |
| ¬øCu√°ntos criterios permite? | Solo uno (el "natural"). | Varios, ya que se pueden definir diferentes comparadores. |
| ¬øSe puede modificar sin alterar la clase original? | No, requiere modificar la clase. | S√≠, sin tocar la clase original. |
| ¬øSe usa en estructuras de datos ordenadas? | S√≠, como `TreeSet` y `TreeMap` por clave. | Tambi√©n, pero con un comparador expl√≠cito. |

**Regla general:**  
- Usa `Comparable` cuando haya un orden natural √∫nico e intuitivo.  
- Usa `Comparator` cuando necesites m√∫ltiples formas de ordenar sin modificar la clase original.

¬øTe gustar√≠a un ejemplo m√°s detallado o alguna optimizaci√≥n? üòä
